\chapter{Architecture}
This chapter describes the architecture and implementation of \toolname{} (portmanteau of ROS and Blockly). First the purpose and need of it are explained, followed by a architectural overview of \hobbit{}, the used robot. Based on this constraints the options implemtenting the tool are presented as well as an explanation of the decision. Then a short description of the robot operating system ROS and the fundamental JavaScript frameworks, Node.js and Express, are given and finally the necessary details of the implementation are documented - for both, the frontend and the backend.

\section{Requirements} \label{sec:requirements}
In the field of software engineering constraints are the basic design parameters. Therefore it is necessary to provide them as detailed as possible. In the given case the basic constraints are given by the purpose of the tool and the architecture of the robot.

\subsection{\hobbit{} - The Mutal Care Robot}
The HOBBIT PT2 (prototype 2) platform was developed within the EU project of the same name. The robot was developed to enable independent living for older adults in their own homes instead of a care facility. The main focus is on fall prevention and detection. PT2 is based on a mobile platform provided by Metralabs. It has an arm to enable picking up objects and learning objects. The head, developed by Blue Danube Robotics, combines the sensor set-up for detecting objects, gestures, and obstacles during navigation. Moreover, the head serves as emotional display and attention center for the user. Human-robot interaction with Hobbit can be done via three input modalities: Speech, gesture, and a touchscreen. \cite{HobbitACIN}\\

\begin{figure}[htbp]
	\centering
	\begin{overpic}[width=0.3\linewidth]{./graphics/Hobbit}
	\end{overpic}
	\caption{\hobbit{} - The Mutal Care Robot}%
	\label{fig:HobbitPic}%
\end{figure}

In terms of technology \hobbit{} (see \prettyref{fig:HobbitPic}) is based on the robot operating system ROS (\prettyref{sub:ros}), which allows easy communication between all components. The system is set up to be used on Ubuntu 16.04 together with the ROS distribution \textit{Kinetic}. All ROS nodes are implemented in either Python or \Cpp{}. In order to provide a fast and simple way to implement new behaviours several commands should be pre-implemented. These commands are performed either by publishing messages to topics or services, or executing callbacks defined in the corresponding action's client. The common commands and their description are listed in \prettyref{tab:hobbitCommands}. A detailed list of possible messages for each command will be presented in \prettyref{sub:ros} after furher explanation of the ROS architecture.

\begin{table}
	\centering
	\begin{tabular}{l l l l}
		\toprule
		Name               & Type    & Message type               & Description            \\
		\midrule
		/cmd\_vel          & Topic   & geometry\_msgs/Twist       & move \hobbit           \\
		/head/move         & Topic   & std\_msgs/String           & move \hobbit's head    \\
		/head/emo          & Topic   & std\_msgs/String           & control \hobbit's eyes \\
		/MMUI              & Service & hobbit\_msgs/Request       & control UI interface   \\
		hobbit\_arm        & Action  & hobbit\_msgs/ArmServer     & control \hobbit's arm  \\
		move\_base\_simple & Action  & geometry\_msgs/PoseStamped & navigate \hobbit       \\
		\bottomrule
	\end{tabular}
	\caption{Common commands used by \hobbit}
	\label{tab:hobbitCommands}
\end{table}

\subsection{Purpose of the tool}
\hobbit{} became very popular since the above mentioned EU project and demos of it's behaviours has been presenting at large number of fairs. Unfortunally only the following show cases are currently implemented on the robot:

\begin{itemize}
	\item \hobbit{} follows the user
	\item \hobbit{} learns object
	\item \hobbit{} starts an emergency call
	\item \hobbit{} picks up an object
\end{itemize}

All of the demos can be started via the UI running on \hobbit{}'s tablet, but re-writing new demos would assume a detailed knowledge of the robot's setup. In order to implement new behaviours and demos more easily it is necessary to provide a programming interface, which provides a powerful, generic base to cover a wide range of \hobbit's features as well as an intuitive handling.\\

Furthermore the \ACIN{} of the TU Wien is part of the Educational Robotics for STEM (ER4STEM) project, which aims to turn curious young children into young adults passionate about science and technology with hands-on workshops on robotics. The ER4STEM framework will coherently offer students aged 7 to 18 as well as their educators different perspectives and approaches to find their interests and strengths in robotics to pursue STEM careers through robotics and semi-autonomous smart devices. \cite{ER4STEMACIN} Providing an intuitive programming tool would allow the integration of \hobbit{} into the project, which would be an extra input evaluation parameter.\\

At last the framework should be implement to be re-used for other ROS based robots. This means, that it should not only provide an interface to the mentioned commands for \hobbit{}, but an open, adpatable framework. It should be able to allow a flexible configuration and assembly of the provided functions.

\section{Options} \label{sec:Options}
There are several approaches to fulfill the mentioned requirements. In the following subsections three different options are presented by a simple example: the implementation of picking up an object from the floor an putting it on the table. This should give a rough overview in terms of complexity of the usability as well as the implementation of the corresponding approach. For reasons of simplicity tasks like searching and detecting the object or gripper positioning are excluded.

\subsection{Custom API}
\label{sub:PyApi}
The most obvious way to fulfill the requirements is to provide an application programming interface (API) for the desired programming languages (Python, \Cpp{}). An API is a set of commands, functions, protocols, and objects that programmers can use to create software or interact with an external system. It provides developers with standard commands for performing common operations so they do not have to write the code from scratch. In the present case such a API could consists of the following components:

\begin{itemize}
	\item Initialization: setting up communication and intial states - e.g. creating ROS nodes, starting the arm referencing or undocking from charger
	\item Topic management: managing the messages published to ROS topics and creating subscriber nodes if applicable
	\item Service management: managing the ROS services of \hobbit{} - e.g. the tablet user interface
	\item Action management: creating ROS action clients for e.g. navigation or arm movement
	\item Common commands: providing common commands (see \prettyref{tab:hobbitCommands})
\end{itemize}

It should be noted, that the components doesn't re-implement ROS functionality, but extend it and prvovide a simpler use of it. Depending of how generic the API is implemented it is possible that the user can control the robot without any detailed knowledge of the technical setup of it. Nevertheless this approach would assume the user to have knowledge of the programming language the API is desigend for. Refering to the required commands in \prettyref{tab:hobbitCommands} an API for Python could be designed as shown in \prettyref{fig:PythonApi}. The highest usability would be reached, if all input parameters are from common variable types such as interger and string. Indeed, this would increase the implementation effort, especially in terms of error handling, as well as the extent of the documentation,  which are huge disadvantages of writing an API. \\

\begin{figure}[htbp]
	\centering
	\begin{overpic}[width=0.8\linewidth]{./graphics/PythonApi}
	\end{overpic}
	\caption{Exemplary design of API for Python}%
	\label{fig:PythonApi}%
\end{figure}

Assuming the API would be implemented as explained before and the Python module would be named \textit{HobbitRosModule}, \prettyref{lst:PythonApiEx} shows a sample code for the mentioned use case to pick up an object. Note that the code is very short and easy to read, which - on the other hand - means that the implementation of the API must cover a broad technical range, such as error handling for unsupported inputs and communication errors.

\begin{figure}[htbp]
	\lstinputlisting[label={lst:PythonApiEx},caption={Example Python code using the API shown in \prettyref{fig:PythonApi}}, language={Python}]{./listings/PythonApiEx.py}
\end{figure}

\subsection{\smach{}}
\smach{} is a task-level architecture for rapidly creating complex robot behavior. At its core, \smach{} is a ROS-independent Python library to build hierarchical state machines. \cite{SmachROS}. Since that, this approach would also end up in providing an API for the user, but allows to create more complex demos with less effort than the one described in \prettyref{sub:PyApi}. \smach{} also provides a powerful graphical viewer to visualize and introspect state machines as well as an integration with ROS, of course. Since the aforementioned example is a very simple one and doesn't require a lot of the provided \smach{} functionality, this section only covers the needed ones to fulfill the requirements. For a detail description on how to use \smach{} refer to \cite{SmachROS}. \\

The arm of \hobbit{} is controlled via the hobbit\_arm action. \smach{} supports calling ROS action interfaces with it's so called \textit{SimpleActionState}, a state class that acts as a proxy to an \textit{actionlib} (see \prettyref{sub:ros}) action. The instantiation of the state takes a topic name, action type, and some policy for generating a goal. When a state finishes, it returns a so called \textit{outcome} - a string that describes how the state finishes. The transition to the next state will be specified based on the outcome of the previous state. \prettyref{lst:SmachExCode} shows a possible implementation of picking up a object an placing it on the table. After the imports of the necessary modules (lines 1 to 4), the state machine is instanced (line 7), to which the required states are added (lines 17-22). The parameters passed to \textit{SimpleActionState} are

\begin{itemize}
	\item the name of the action as it will be broadcast over ROS (e.g. \textit{hobbit\_arm})
	\item the type of action to which the client will connect (e.g. \textit{ArmServerAction}) and
	\item the goal message.
\end{itemize}

For reasons of readability the goals are declared at a seperate code block (lines 11 to 14). The equivalent visualization of the state machine is shown in \prettyref{fig:SmachSM}. \\

\begin{figure}[htbp]
	\lstinputlisting[label={lst:SmachExCode},caption={Using \smach{} to generate a state machine}, language={Python}]{./listings/SmachEx.py}
\end{figure}

\begin{figure}[htbp]
	\centering
	\begin{overpic}[width=0.7\linewidth]{./graphics/SmachSM}
	\end{overpic}
	\caption{State machine generated via \prettyref{lst:SmachExCode}}%
	\label{fig:SmachSM}%
\end{figure}

Providing just the \smach{} interface has some disadvantages and would not be practicable. First the user would need an advanced knowledge of Python. Depending on the design of the self-implemented API (\prettyref{sub:PyApi}) the knowledge has to be at least at the same level. Next the user would have to understand the API and needs to find a design to fit for the corresponding demo case. Furthermore it requires the user also to exactly know the ROS specification of the robot. So, if \smach{} would be choosen as the underlying framework, it would also be necessary to provide a more abstract API - basically with the same interfaces as shown in \prettyref{fig:PythonApi}.

\subsection{Blockly} \label{sub:Blockly}
Blockly is a library that adds a visual code editor to web and Android apps. The Blockly editor uses interlocking, graphical blocks to represent code concepts like variables logical expressions, loops, and more. It allows users to apply programming principles without having to worry about syntax or the intimidation of a blinking cursor on the command line. \cite{BlocklyIntro} So for the present case, in contrast to the other approaches the user would not need to have any technical knowledge of \hobbit{}, its components and interfaces. Furthermore such a editor would not require the user to master any programming language. On the other hand implementing this approach would require knowledge of web applications (i.e. JavaScript, HTML and CSS) additionally. \\

\begin{figure}[htbp]
	\centering
	\begin{overpic}[width=0.9\linewidth]{./graphics/BlocklyEx}
	\end{overpic}
	\caption{A short Blockly demo showing it's structure and use}%
	\label{fig:BlocklyEx}%
\end{figure}

\prettyref{fig:BlocklyEx} shows an exemplary injection and use as well as the basic structure of Blockly applications. It consists of a toolbox, from where the progamming blocks can dragged to the workspace, where they are connected. The Blockly API \cite{BlocklyAPI} provides a function to generate code for all blocks in the workspace to several languages: JavaScript, Python, PHP, Lua, Dart and XML. In the shown example for each of them a tab is avaible to show the generated code. The blocks dragged to the workspace in \prettyref{fig:BlocklyEx} are already customized blocks, with whom an object can be picked up and be placed on the table. There are basically four steps requierd in order to create and use a custom block, which are described briefly in the following paragraphs. A detailed documentation is given in \cite{BlocklyCustomBlocks}.

\subsubsection{Defining the block}
Blocks are defined in the \lstinline!/blocks/! directory of the source code by adding either JSON objects or JavaScript functions to the \lstinline!Blockly.Blocks! mapping. It includes the specification of the shape, fields, tooltip and connection points. An exampe definition using a JavaScript function of the \textit{gripper} block is shown in \prettyref{lst:DefineBlockEx}. Attention should be payed to lines 6 to 21, where the input fields are defined (line 8). Here a dropdown field with two options ("Open" and "Close") is created. The name ("gripper\_position") is used to refer to it later.

\begin{figure}[htbp]
	\lstinputlisting[label={lst:DefineBlockEx},caption={Block initialization using a JavaScript function}, language={JavaScript}]{./listings/BlocklyBlockInitEx.js}
\end{figure}

\subsubsection{Providing the code}
Similar to the definition of a block, the code, which is generated out of them, is stored in a mapping variable inside the Blockly library. Since different languages are supported, the code definition has to be in the right directory. Note that it is not necessary to provided code for each language. The code generation is handled in the \lstinline!/generator/! directory of the library. Each language has it's own helper functions file (e.g. \lstinline!python.js!) and subdirectory, where the code for each block is defined. There are several interfaces functions provided by Blockly to manage interaction with a block - such as collecting arguments of the block. A short example to control \hobbit{}'s gripper is shown \prettyref{lst:DefineCodeEx}. In line 2 the \lstinline!block.getFieldValue()! function is used to get the user's selection of the dropdown field. Note that the generator always returns a string variable including the code in the desired language (line 4). So the shown example requires to use a custom Python API (such as \prettyref{fig:PythonApi}), because \lstinline!node.gripper()! is not a built-in function of Python. \\

\begin{figure}[htbp]
	\lstinputlisting[label={lst:DefineCodeEx},caption={Defintion of a code generator in Blockly for Python}, language={JavaScript}]{./listings/BlocklyCodeInitEx.js}
\end{figure}

\subsubsection{Building}
After the customized block and it's code generator are defined, the whole Blockly project has to be rebuilt by running \lstinline!python build.py!. Building means that the source code, which is usually spread to several - in the given case over a hundred - files, is converted into a stand-alone form, that can be easily integrated. The Blockly build process uses Google's online Closure Compile and outputs compressed JavaScript files for core functionalites, blocks, block generators for each progamming language and a folder including JavaScript files for messages in several lingual languages. In our case the following four files needs to be included:

\begin{itemize}
	\item \lstinline!blockly_compressed.js!: Blockly core functionalites
	\item \lstinline!blocks_compressed.js!: Defintion of all blocks
	\item \lstinline!python_compressed.js!: Code generators for all blocks
	\item \lstinline!/msg/js/en.js!: English messages for e.g. tooltips
\end{itemize}

\subsubsection{Add it to the toolbox}
Once the building is completed and the necessary files are included to the web application, the custom block needs to be included in the toolbox. The toolbox is specified in XML and passed to Blockly when it is injected. Assuming the blocks shown in \prettyref{fig:BlocklyEx} are build as described in the previous paragraphs, they can be add to the toolbox as shwon in \prettyref{lst:DefineToolboxEx}. \\

\begin{figure}[htbp]
	\lstinputlisting[label={lst:DefineToolboxEx},caption={Minimal example of adding two blocks to a Blockly toolbox}, language={XML}]{./listings/BlocklyToolboxEx.xml}
\end{figure}

\subsection{Decision}
In order to select the best fitting solution the requirements explained in \prettyref{sec:requirements} are summarized as follows:

\begin{itemize}
	\item The user wants to build as complex demos as possible.
	\item The user wants an intuitive interface to create demos.
	\item The user should need as little knowledge of the robot as possible.
	\item The user should need as little technical knowledge as possible.
	\item The implementation of the tool should not exceed the usual effort of a master thesis.
	\item The tool should provide the ability to add new functionalites.
	\item The tool should be maintable, meaning it should have clear interfaces and as less dependencies as possible.
\end{itemize}

The selection is based on rating each of the approaches in regards of each single requirement mentioned with a score ranging from 0 (lowest) to 5 (highest). The approach with the highest overall score is seen as the best fitting one and will be implemented. \prettyref{tab:decision} shows the result of the evaluation. In the end the Blockly convinced with its very intuitive interface, which requires the user to have very little previous knowledge to build demos. Despite the fact that maintainability and scalability suffer from the high abstraction and encapsulation of the libary, the effort in terms of implementation is not worth mentioning compared to the other approaches. This results from the circumstance each one would require the design of a custom API. Instead of just abstracting the given ROS functionality, Blockly adds a much more user-friendly option to create demos - in contrast to the others.

\begin{table}[htbp]
	\centering
	\begin{tabular}{l c c c}
		\toprule
		                        & Custom API & \smach{} & Blockly \\
		\midrule
		Complexity of demos     & 3          & 4        & 2       \\
		User Interface          & 2          & 2        & 5       \\
		Robot specific know-how & 3          & 1        & 5       \\
		Technical know-how      & 1          & 1        & 5       \\
		Implementation          & 2          & 3        & 3       \\
		Scalability             & 4          & 3        & 2       \\
		Maintainability         & 3          & 3        & 1       \\
		% Dependencies            & 4                 & 2        & 2       \\
		\bottomrule
		$\Sigma$                & 18         & 17       & 23      \\
		\bottomrule
	\end{tabular}
	\caption{Evaluation of possible approaches}
	\label{tab:decision}
\end{table}

\section{Overview}
\prettyref{fig:Architecture} gives an overview of \toolname{}'s architecture and it's components. While the frontend consists of the following five components:

\begin{itemize}
	\item a \textbf{Demo Management} which allows the user to create, edit, delete and run demos easily,
	\item a \textbf{Code Editor} to allow further editing of the generate code before running it on the robot,
	\item the \textbf{Code Generation} with the help of Blockly - the heart of the tool,
	\item an interface for creating and managing custom blocks (\textbf{Block Configuration}, which then can be used for code generation,
	\item sending and receiving data from the robot via the \textbf{Backend Communication}
\end{itemize}

the backend is made up of the following four:

\begin{itemize}
	\item sending and receiving data from the user interface via the \textbf{Frontend Communication},
	\item a \textbf{Storage Management}, which provides the demos and custom blocks to the user,
	\item a \textbf{Python Module} containing all necessary functionalites to provide an ROS executable code,
	\item an interface to finally execute the generated code on the robot (\textbf{Code Execution}).
\end{itemize}


\begin{figure}[htbp]
	\centering
	\begin{overpic}[width=\linewidth]{./graphics/Architecture}
	\end{overpic}
	\caption{Frontend and backend architecture of \toolname{}}%
	\label{fig:Architecture}%
\end{figure}

\section{Supporting frameworks \& dependencies}
As described the components can be clustered into frontend and backend, but they also can be seen in respect of their functional interfaces. On the one hand there is a connection to the robots sensors and actuators, on the other hand there is an interface to the human using the tool. Both functionalites are build up with the support of software frameworks, which are described in the following sections.

\subsection{ROS} \label{sub:ros}
ROS (Robot Operating System) provides libraries and tools to help software developers create robot applications. It provides hardware abstraction, device drivers, libraries, visualizers, message-passing, package management, and more. Since ROS is licensed under an open source, BSD license it used for a wide range of robots, sensors and motors. Covering all of its features would go beyond the scope of this thesis, so just the concepts, which are needed to implement \toolname{}, are summarized. \cite{WikiROS}

\subsubsection{Packages}
Software in ROS is organized in packages. A package might contain ROS nodes, a ROS-independent library, a dataset, configuration files, a third-party piece of software, or anything else that logically constitutes a useful module. The goal of these packages is to provide this useful functionality in an easy-to-consume manner so that software can be easily reused.

\subsubsection{Nodes}
A node is a process that performs computation and are written with the use of a ROS client library, such as roscpp (for \Cpp{}) or rospy (for Python). Nodes are combined together into a graph and communicate with one another using streaming topics, RPC (Remote Procedure Call) services, and the Parameter Server. A robot control system will usually comprise many nodes. For example, one node controls a laser range-finder, one node controls the robot's wheel motors, one node performs localization, one node performs path planning, and so on.

\subsubsection{Topics}
Topics are named buses over which nodes exchange messages. Topics have anonymous publish/subscribe semantics, which decouples the production of information from its consumption. In general, nodes are not aware of who they are communicating with. Instead, nodes that are interested in data subscribe to the relevant topic; nodes that generate data publish to the relevant topic. There can be multiple publishers and subscribers to a topic. Each topic is strongly typed by the ROS message type used to publish to it and nodes can only receive messages with a matching type.

\subsubsection{Messages}
A message is a simple data structure, comprising typed fields. Standard primitive types (integer, floating point, boolean, etc.) are supported, as are arrays of primitive types. Messages can include arbitrarily nested structures and arrays. Nodes can also exchange a request and response message as part of a ROS service call. Message descriptions are stored in .msg files in the \lstinline!/msg/! subdirectory of a ROS package.

\subsubsection{Services}
The publish-subscribe model is a very flexible communication paradigm, but its many-to-many one-way transport is not appropriate for RPC request-reply interactions, which are often required in a distributed system. Request-reply in ROS is done via a service, which is defined by a pair of messages: one for the request and one for the reply. Services are defined using .srv files, which are compiled into source code by a ROS client library.

\subsubsection{Actions}
In some cases, e.g. if a service takes a long time to execute, the user might want the ability to cancel the request during execution or get periodic feedback about how the request is progressing. The actionlib package provides tools to create servers that execute long-running goals that can be preempted. It also provides a client interface in order to send requests to the server.
The action client and action server communicate via a "ROS Action Protocol", which is built on top of ROS messages. The client and server then provide a simple API for users to request goals (on the client side) or to execute goals (on the server side) via function calls and callbacks.

\subsection{JavaScript frameworks} \label{sub:jsFrameworks}
Since \toolname{} is a web application all of the functionality blocks do touch JavaScript in any way. And since there are a lot of JavaScript frameworks supporting the development of web applications, it's necessary to get an overview of the important ones - besides Blockly (see \prettyref{sub:Blockly}) - used to implement \toolname{} before diving into the implementation itself.

\subsubsection{Node.js}
% \subsection{Node.js \& Express}
Node.js is an open source platform that allows you to build fast and scalable network applications using JavaScript. Node.js is built on top of V8, a modern JavaScript virtual machine that powers Google's Chrome web browser. At its core, one of the most powerful features of Node.js is that it is event-driven. This means that almost all the code written in Node.js is going to be written in a way that is either responding to an event or is itself firing an event (which in turn will fire other code listening for that event). In an effort to make the code as modular and reusable as possible, Node.JS uses a module system - called  "Node Package Manager" (NPM) - that allows to better organize the code and makes it easy to use third-party open source modules.

\subsubsection{Express}
Express is a minimal and flexible Node.js web application framework, providing a robust set of features for building single, multi-page, and hybrid web applications. In other words, it provides all the tools and basic building blocks one need to get a web server up and running by writing very little code. \prettyref{lst:ExpressHelloWorld} shows a minimal example of using Node.js and Express to implement the famous "Hello World" program. First the Express module is imported (Line 1) and an instance of the app is created (Line 2), which finally listens to the configured port (Line 6). Line 3 to 5 describes the mentioned event-driven behavior: \lstinline!app.get('/',...)! causes every request to trigger the given callback function, which in this case is just sending the "Hello World" string.

\begin{figure}[htbp]
	\lstinputlisting[label={lst:ExpressHelloWorld},caption={"Hello World" program implemented using Node.js and Express}, language={JavaScript}]{./listings/ExpressEx.js}
\end{figure}

\subsubsection{Ace}
Ace, whose name is derived from "Ajax.org Cloud9 Editor", is a standalone code editor written in JavaScript. Ace is developed as the primary editor for Cloud9 IDE - an online integrated development environment -  and the successor of the Mozilla Skywriter (formerly Bespin) Project. It supports syntax highlighting and auto formatting of the code as well as customizable keyboard shortcuts.

\subsubsection{jQuery}
jQuery is a fast, small, and feature-rich JavaScript library. It makes things like HTML document traversal and manipulation, event handling, animation and ajax (Asynchronous JavaScript and XML) much simpler with an easy-to-use API that works across a multitude of browsers. \toolname{} basically uses its functionality to exchange data via RESTful (Representational State Transfer) web services and manipulating HTML elements.

\section{Backend \& Frontend Communication}
The communication between frontend (client) and backend (server) is done via a RESTful API. A RESTful API is based on representational state transfer (REST) technology and uses HTTP (Hypertext Transfer Protocol) request methods, which are defined in RFC 2616 \cite{RFC2616}, to exchange data between web services. All implemented API endpoints, which are used to manage demos and codes are listed in \prettyref{tab:APIspec}.

\begin{table}[htbp]
	\centering
	\begin{tabular}{l l l}
		\toprule
		Type   & Path                               & Description                                     \\
		\midrule
		GET    & /demo/list                         & list all demos saved on the robot               \\
		GET    & /demo/load/\textit{\{demoId\}}     & get the \lstinline!.xml! tree for a demo        \\
		POST   & /demo/save                         & save a new demo on the robot                    \\
		POST   & /demo/run/\textit{\{demoId\}}      & run a demo                                      \\
		DELETE & /demo/delete\textit{\{demoId\}}    & delete a demo                                   \\
		GET    & /demo/toolbox                      & load the toolbox of the Blockly interface       \\
		GET    & /block/list                        & list all already configured custom blocks       \\
		POST   & /block/create                      & create a new custom block                       \\
		PUT    & /block/update/\textit{\{blockId\}} & update a custom block                           \\
		DELETE & /block/delete/\textit{\{blockId\}} & delete a custom block                           \\
		\bottomrule
	\end{tabular}
	\caption{API endpoints for managing demos and custom blocks}
	\label{tab:APIspec}
\end{table}


\section{Demo Management}
The Demo Management (\prettyref{fig:DemoManagement}) is one key feature of \toolname{} and the entry point of it. It gives an overview of all avaible demos, meaning demos, which are saved on the robot in a specific directory. It provides a graphical interface and hence makes it a lot easier to manage and run demos - in contrast to the other mentioned options (\prettyref{sec:Options}), where e.g. the user needs to explicity locate the file and run it. Since usability and simplicity are main requirements for this tool, such a feature is a main advantage of it. Furthermore the main page provides the option to create new demos and a redirection to the block configuration component (\prettyref{sec:BlockConfiguration}).

\begin{figure}[htbp]
	\centering
	\begin{overpic}[width=\linewidth]{./graphics/DemoManagementFrontend}
	\end{overpic}
	\caption{Demo Management Page}%
	\label{fig:DemoManagement}%
\end{figure}

At the start of the tool the \lstinline!/demos/! directory inside the tools folder on the robot is searched for saved demos. Since we talking about a web-based tool and demos are saved on the robot, this requieres a call to the backend, which then returns a list of all demos via the RESTful API. The structure of all demos are stored in \lstinline!.xml! files, which are interpreted by Blockly.

\section{Block Configuration} \label{sec:BlockConfiguration}
There are a lot of needs a user want to create a custom block. The pre-implemented blocks are designed for the ROS architecture of \hobbit{} and any other robot won't show the desired behavior when receiving commands sent from these blocks. Even for \hobbit{} itself the provided block set doesn't cover all of its functionalites. Using another robot means publishing different data to other topics, calling other services and using other action clients. Of course, the user can walk through the whole custom block creation process described in \prettyref{sub:Blockly} to create new blocks. This requieres knowledge of progamming in JavaScript and the Blockly API. The user would then can use all of Blockly's broad range of features and advantages, especially dynamically changing of block features.

On the other hand for a lot of the tasks such features aren't necessary or a workaround with less effort can be found, respectively. For this reason \toolname{} provides a block configuration interface, which allows the user to create custom blocks with the two basic visual designs: an execution block and an input block (\prettyref{fig:CustomBlockTypes}). With this interface the user can configure blocks for publishing data to topics, calling services with parameters and creating simple action clients.

\begin{figure}[htbp]
	\centering
	\begin{overpic}[width=0.5\linewidth]{./graphics/ExCustomBlockTypes}
	\end{overpic}
	\caption{Basic visual designs: execution block (left) and input block (right)}%
	\label{fig:CustomBlockTypes}%
\end{figure}

The design of the interface is shown in \prettyref{fig:BlockConfiguration}. It is devided into three sections:
\begin{enumerate}[I.]
	\item An overview of already created custom blocks
	\item A form to provide general information of the block
	\item A form to provide detail information of the block (type-specific)
\end{enumerate}

\begin{figure}[htbp]
	\centering
	\begin{overpic}[width=0.8\linewidth]{./graphics/BlockConfiguration}
	\end{overpic}
	\caption{Design of the block configuration interface}%
	\label{fig:BlockConfiguration}%
\end{figure}

The list of all already configured custom blocks is loaded via the GET request endpoint \lstinline!/block/list! of the tool's internal RESTful API. The request delivers an object with the Blockly conform block and code definitions, the unique ID and name of the respective block as well as the block's meta data. The latter is used to set the general and detail forms in case the custom block is selected. Identification which custom block is selected is handeld via the query string of the URL, which is set to the custom block's ID if it is selected. The ID of a block is a alphanumerical 12-character string, which is generated randomly. \\

The general information form is primarily used to set the visual design of the block. The user can configure the title and tooltip of the block as well as the number and names of the inputs, which then can be used in the detail section. The detail section varies depending on which type of the ROS communicating patterns is used. A topic must be specified by its name, the message type and the message itself. If the user wants to create a custom block for calling services, it is necessary to provide the name of the service, the message type and a list of all message type specific fields with their values. Furthermore it is possible to choose whether the response of the service should be used as output - which will lead to an input block - or not - then an execution block is generated (\prettyref{fig:CustomBlockTypes}). The detail section for actions includes fields for setting the execution timeout (which is defined as the time to wait for the goal to complete), the server name, the message type and the goal. It is also possible to provide the following callback functions:

\begin{itemize}
	\item done\_cb: callback that gets called on transitions to  \textit{Done} state.
	\item active\_cb: callback that gets called on transitions to  \textit{Active} state.
	\item feedback\_cb: callback that gets called whenever feedback for the goal is received.
\end{itemize}

All detail sections also features an input field for importing all Python packages that are needed to execute the code correctly, e.g. messages types that are used to generate the message. Some step-by-step examples for configuring custom blocks are presented in \prettyref{apx:BlockConfigManual}.

\section{Code Generation}

\begin{figure}[htbp]
	\centering
	\begin{overpic}[width=\linewidth]{./graphics/CodeGenerationScreen}
	\end{overpic}
	\caption{User interface for demo and code generation}%
	\label{fig:CodeGeneration}%
\end{figure}

Demos are created via the user interface shown in \prettyref{fig:CodeGeneration}. It can be devided into three sections:

\begin{enumerate}[I.]
	\item the \textbf{navigation header} holds elements to directly manage the current demo,
	\item the \textbf{toolbox} contains code blocks organized in categories,
	\item the \textbf{workspace} where the blocks can be dragged to from the toolbox and connected with each other.
\end{enumerate}

Blocks which are dragged to and combined at the workspace creates are used to generate an executable code. This is done with the help of Blockly (see \prettyref{sub:Blockly}). Blockly came up with some predefined code blocks that allow some basic programming procedures.
On top of them \toolname{} provides further blocks, which allows to connect to \hobbit{} and perform several actions (\prettyref{tab:hobbitCommands}). A list and description of these blocks can be found in \prettyref{apx:BlockOverview}. All of them are using one of the mentioned ROS communicating pattern (topic, service, action) to call the interface of the robot and have a similar structure thanks to the design of a custom Python module (\prettyref{sec:PythonModule}). \\

To get a clearer understanding of the general structure of these blocks and the Blockly custom block creation (\prettyref{sub:Blockly}) an explicit example is presented. The choosen examaple shows the block and code definition to create a block, which allows to move \hobbit{} a given distance into a given direction (\prettyref{fig:ExBlockMove}).

\begin{figure}[htbp]
	\centering
	\begin{overpic}[width=0.3\linewidth]{./graphics/blocks/move}
	\end{overpic}
	\caption{Example block to be created}%
	\label{fig:ExBlockMove}%
\end{figure}

The full block definition for the mentioned example is given in \prettyref{lst:MoveHobbitBlock}. Lines 2 and 3 indicates, that the block is initialized using a JavaScript function (same as in \prettyref{lst:DefineBlockEx}). In lines 1 and 4 the name and type of the block are set, which is important to get the assign the corresponding code object later on. The \lstinline!message0! key is used to set the message displayed on the block, whereas the placeholders (\%1,\%2) are replaced by the arguments given by the objects passed to the \lstinline!args0! key. In the presented case the first argument is an input field and must be a number (lines 8,10) and the second one (lines 13 to 24) a dropdown field with options "forward" and "backward" displayed. To get the passed values for code generation a name for each paramter is set (lines 9,14). Lines 27 and 28 indicates that the block has connections on the top and bottom, but there are no constraints for them. The last three lines are just used to set the color, tooltip and an optional help URL. \\

\begin{figure}[htbp]
	\lstinputlisting[label={lst:MoveHobbitBlock},caption={Full block initialization for moving \hobbit{} forward and backward}, language={JavaScript}]{./listings/ExMoveHobbitBlock.js}
\end{figure}

\begin{figure}[htbp]
	\lstinputlisting[label={lst:MoveHobbitCode},caption={Full code initialization for moving \hobbit{} forward and backward}, language={JavaScript}]{./listings/ExMoveHobbitCode.js}
\end{figure}

The corresponding code initialization is shown in \prettyref{lst:MoveHobbitCode}. Line 1 again shows the internal design of Blockly, which is based on assigning functions and objects to classes. Blockly supports code generation for several programming languages, which all are implemented in seperate classes. Since the presented tool should convert blocks into Python code, the Python class is used. Within the code initialization first the input values of the block are read through the provided API (line 2,3). Then some ROS specific initialization is done (line 4), which basically handles the import of the rospy package and the custom Python module as well as creating a ROS node. The name of the node is defined by the constant string \lstinline!Blockly.Python.NodeName! and an instance of a certain class of the Python module. \lstinline!Blockly.Python.InitROS()! is a custom command and must be included in the code initialization of each block. Finally the code string is assembled by just calling the corresponding control function of the ROS node instance with the input parameters (line 6) and then returned (line 7).

The code initialization of each created block follows the mentioned steps, which can be summarized as follows:
\begin{enumerate}
	\item Getting the values of the inputs.
	\item Initialization of the ROS interface
	\item Assembly of the code string by simply calling the responding functions of the Python module
\end{enumerate}

This generic design is another decrease of the conditions - in terms of JavaScript knowledge - for using the Blockly framework, because it outsources the main and most complex task of assembling the executing code to an interface more robot programmers are familiar with. Futhermore Google provides a visual interface - using the Blockly framework itself - to easily create the block configuration object. \footnote{https://blockly-demo.appspot.com/static/demos/blockfactory/index.html}

\section{Code Editor}
The generated code can be accessed by clicking on the \textit{Code} tab on the user interface (\prettyref{fig:CodeGeneration}). It provides the opportunity to add further functionality to the code, which is not already covered by the tool, before execute the demo or save it. This could be very basic modification, e.g. just adding comments to code or inserting debugging messages, or more advanced ones, e.g. adding the functionality to subscribe to a topic.

This makes \toolname{} not only to be a stand-alone solution for basic use cases, but a supporting tool for more experienced users, who don't want to build their code from the scratch.

\begin{figure}[htbp]
	\lstinputlisting[label={lst:AceInject},caption={Embedding Ace, setting preferences and displaying the generated code}, language={JavaScript}]{./listings/AceInject.js}
\end{figure}

The implementation of the provided editor basically involve just embedding Ace via its API (see \prettyref{sub:jsFrameworks}). The basic embedding code is shown in \prettyref{lst:AceInject}. It also shows how connected blocks on the workspace are translated into an executable Python code (Line 2) and to display the generated code (Line 10). The variable \textit{workspace} is an instance of the static class \textit{Blockly.Workspace}. \footnote{https://developers.google.com/blockly/reference/js/Blockly}

\section{Python Module} \label{sec:PythonModule}

\section{Storage Management}

\section{Code Execution}